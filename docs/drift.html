<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>eyekit.drift API documentation</title>
<meta name="description" content="These implementations of eight vertical drift algorithms are taken
from https://github.com/jwcarr/drift" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eyekit.drift</code></h1>
</header>
<section id="section-intro">
<p>These implementations of eight vertical drift algorithms are taken
from <a href="https://github.com/jwcarr/drift">https://github.com/jwcarr/drift</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
These implementations of eight vertical drift algorithms are taken
from https://github.com/jwcarr/drift
&#39;&#39;&#39;

import numpy as _np

######################################################################
# ATTACH
######################################################################

def attach(fixation_XY, line_Y):
        n = len(fixation_XY)
        for fixation_i in range(n):
                line_i = _np.argmin(abs(line_Y - fixation_XY[fixation_i, 1]))
                fixation_XY[fixation_i, 1] = line_Y[line_i]
        return fixation_XY

######################################################################
# CHAIN
# 
# https://github.com/sascha2schroeder/popEye/
######################################################################

def chain(fixation_XY, line_Y, x_thresh=192, y_thresh=32):
        n = len(fixation_XY)
        dist_X = abs(_np.diff(fixation_XY[:, 0]))
        dist_Y = abs(_np.diff(fixation_XY[:, 1]))
        end_chain_indices = list(_np.where(_np.logical_or(dist_X &gt; x_thresh, dist_Y &gt; y_thresh))[0] + 1)
        end_chain_indices.append(n)
        start_of_chain = 0
        for end_of_chain in end_chain_indices:
                mean_y = _np.mean(fixation_XY[start_of_chain:end_of_chain, 1])
                line_i = _np.argmin(abs(line_Y - mean_y))
                fixation_XY[start_of_chain:end_of_chain, 1] = line_Y[line_i]
                start_of_chain = end_of_chain
        return fixation_XY

######################################################################
# CLUSTER
# 
# https://github.com/sascha2schroeder/popEye/
######################################################################

def cluster(fixation_XY, line_Y):
        try:
                from sklearn.cluster import KMeans
        except ImportError:
                raise ImportError(&#39;The cluster method requires sklean. pip install sklearn&#39;)
        m = len(line_Y)
        fixation_Y = fixation_XY[:, 1].reshape(-1, 1)
        clusters = KMeans(m, n_init=100, max_iter=300).fit_predict(fixation_Y)
        centers = [fixation_Y[clusters == i].mean() for i in range(m)]
        ordered_cluster_indices = _np.argsort(centers)
        for fixation_i, cluster_i in enumerate(clusters):
                line_i = _np.where(ordered_cluster_indices == cluster_i)[0][0]
                fixation_XY[fixation_i, 1] = line_Y[line_i]
        return fixation_XY

######################################################################
# MERGE
#
# Špakov, O., Istance, H., Hyrskykari, A., Siirtola, H., &amp; Räihä,
#   K.-J. (2019). Improving the performance of eye trackers with
#   limited spatial accuracy and low sampling rates for reading
#   analysis by heuristic fixation-to-word mapping. Behavior Research
#   Methods, 51(6), 2661–2687.
#
# https://doi.org/10.3758/s13428-018-1120-x
# https://github.com/uta-gasp/sgwm
######################################################################

phases = [{&#39;min_i&#39;:3, &#39;min_j&#39;:3, &#39;no_constraints&#39;:False}, # Phase 1
          {&#39;min_i&#39;:1, &#39;min_j&#39;:3, &#39;no_constraints&#39;:False}, # Phase 2
          {&#39;min_i&#39;:1, &#39;min_j&#39;:1, &#39;no_constraints&#39;:False}, # Phase 3
          {&#39;min_i&#39;:1, &#39;min_j&#39;:1, &#39;no_constraints&#39;:True}]  # Phase 4

def merge(fixation_XY, line_Y, y_thresh=32, g_thresh=0.1, e_thresh=20):
        n = len(fixation_XY)
        m = len(line_Y)
        diff_X = _np.diff(fixation_XY[:, 0])
        dist_Y = abs(_np.diff(fixation_XY[:, 1]))
        sequence_boundaries = list(_np.where(_np.logical_or(diff_X &lt; 0, dist_Y &gt; y_thresh))[0] + 1)
        sequence_starts = [0] + sequence_boundaries
        sequence_ends = sequence_boundaries + [n]
        sequences = [list(range(start, end)) for start, end in zip(sequence_starts, sequence_ends)]
        for phase in phases:
                while len(sequences) &gt; m:
                        best_merger = None
                        best_error = _np.inf
                        for i in range(len(sequences)-1):
                                if len(sequences[i]) &lt; phase[&#39;min_i&#39;]:
                                        continue # first sequence too short, skip to next i
                                for j in range(i+1, len(sequences)):
                                        if len(sequences[j]) &lt; phase[&#39;min_j&#39;]:
                                                continue # second sequence too short, skip to next j
                                        candidate_XY = fixation_XY[sequences[i] + sequences[j]]
                                        gradient, intercept = _np.polyfit(candidate_XY[:, 0], candidate_XY[:, 1], 1)
                                        residuals = candidate_XY[:, 1] - (gradient * candidate_XY[:, 0] + intercept)
                                        error = _np.sqrt(sum(residuals**2) / len(candidate_XY))
                                        if phase[&#39;no_constraints&#39;] or (abs(gradient) &lt; g_thresh and error &lt; e_thresh):
                                                if error &lt; best_error:
                                                        best_merger = (i, j)
                                                        best_error = error
                        if best_merger is None:
                                break # no possible mergers, break while and move to next phase
                        merge_i, merge_j = best_merger
                        merged_sequence = sequences[merge_i] + sequences[merge_j]
                        sequences.append(merged_sequence)
                        del sequences[merge_j], sequences[merge_i]
        mean_Y = [fixation_XY[sequence, 1].mean() for sequence in sequences]
        ordered_sequence_indices = _np.argsort(mean_Y)
        for line_i, sequence_i in enumerate(ordered_sequence_indices):
                fixation_XY[sequences[sequence_i], 1] = line_Y[line_i]
        return fixation_XY

######################################################################
# REGRESS
#
# Cohen, A. L. (2013). Software for the automatic correction of
#   recorded eye fixation locations in reading experiments. Behavior
#   Research Methods, 45(3), 679–683.
#
# https://doi.org/10.3758/s13428-012-0280-3
# https://blogs.umass.edu/rdcl/resources/
######################################################################

def regress(fixation_XY, line_Y, k_bounds=(-0.1, 0.1), o_bounds=(-50, 50), s_bounds=(1, 20)):
        try:
                from scipy.optimize import minimize
                from scipy.stats import norm
        except ImportError:
                raise ImportError(&#39;The regress method requires scipy. pip install scipy&#39;)
        n = len(fixation_XY)
        m = len(line_Y)

        def fit_lines(params, return_line_assignments=False):
                k = k_bounds[0] + (k_bounds[1] - k_bounds[0]) * norm.cdf(params[0])
                o = o_bounds[0] + (o_bounds[1] - o_bounds[0]) * norm.cdf(params[1])
                s = s_bounds[0] + (s_bounds[1] - s_bounds[0]) * norm.cdf(params[2])
                predicted_Y_from_slope = fixation_XY[:, 0] * k
                line_Y_plus_offset = line_Y + o
                density = _np.zeros((n, m))
                for line_i in range(m):
                        fit_Y = predicted_Y_from_slope + line_Y_plus_offset[line_i]
                        density[:, line_i] = norm.logpdf(fixation_XY[:, 1], fit_Y, s)
                if return_line_assignments:
                        return density.argmax(axis=1)
                return -sum(density.max(axis=1))

        best_fit = minimize(fit_lines, [0, 0, 0])
        line_assignments = fit_lines(best_fit.x, True)
        for fixation_i, line_i in enumerate(line_assignments):
                fixation_XY[fixation_i, 1] = line_Y[line_i]
        return fixation_XY

######################################################################
# SEGMENT
#
# Abdulin, E. R., &amp; Komogortsev, O. V. (2015). Person verification via
#   eye movement-driven text reading model, In 2015 IEEE 7th
#   International Conference on Biometrics Theory, Applications and
#   Systems. IEEE.
#
# https://doi.org/10.1109/BTAS.2015.7358786
######################################################################

def segment(fixation_XY, line_Y):
        n = len(fixation_XY)
        m = len(line_Y)
        diff_X = _np.diff(fixation_XY[:, 0])
        saccades_ordered_by_length = _np.argsort(diff_X)
        line_change_indices = saccades_ordered_by_length[:m-1]
        current_line_i = 0
        for fixation_i in range(n):
                fixation_XY[fixation_i, 1] = line_Y[current_line_i]
                if fixation_i in line_change_indices:
                        current_line_i += 1
        return fixation_XY

######################################################################
# SPLIT
######################################################################

def split(fixation_XY, line_Y):
        n = len(fixation_XY)
        diff_X = _np.diff(fixation_XY[:, 0])
        clusters = KMeans(2, n_init=10, max_iter=300).fit_predict(diff_X.reshape(-1, 1))
        centers = [diff_X[clusters == 0].mean(), diff_X[clusters == 1].mean()]
        sweep_marker = _np.argmin(centers)
        end_line_indices = list(_np.where(clusters == sweep_marker)[0] + 1)
        end_line_indices.append(n)
        start_of_line = 0
        for end_of_line in end_line_indices:
                mean_y = _np.mean(fixation_XY[start_of_line:end_of_line, 1])
                line_i = _np.argmin(abs(line_Y - mean_y))
                fixation_XY[start_of_line:end_of_line, 1] = line_Y[line_i]
                start_of_line = end_of_line
        return fixation_XY

######################################################################
# WARP
######################################################################

def warp(fixation_XY, word_XY):
        _, dtw_path = dynamic_time_warping(fixation_XY, word_XY)
        for fixation_i, words_mapped_to_fixation_i in enumerate(dtw_path):
                candidate_Y = word_XY[words_mapped_to_fixation_i, 1]
                fixation_XY[fixation_i, 1] = mode(candidate_Y)
        return fixation_XY

def mode(values):
        values = list(values)
        return max(set(values), key=values.count)

######################################################################
# Dynamic Time Warping adapted from https://github.com/talcs/simpledtw
# This is used by the WARP algorithm
######################################################################

def dynamic_time_warping(sequence1, sequence2):
        n1 = len(sequence1)
        n2 = len(sequence2)
        dtw_cost = _np.zeros((n1+1, n2+1))
        dtw_cost[0, :] = _np.inf
        dtw_cost[:, 0] = _np.inf
        dtw_cost[0, 0] = 0
        for i in range(n1):
                for j in range(n2):
                        this_cost = _np.sqrt(sum((sequence1[i] - sequence2[j])**2))
                        dtw_cost[i+1, j+1] = this_cost + min(dtw_cost[i, j+1], dtw_cost[i+1, j], dtw_cost[i, j])
        dtw_cost = dtw_cost[1:, 1:]
        dtw_path = [[] for _ in range(n1)]
        while i &gt; 0 or j &gt; 0:
                dtw_path[i].append(j)
                possible_moves = [_np.inf, _np.inf, _np.inf]
                if i &gt; 0 and j &gt; 0:
                        possible_moves[0] = dtw_cost[i-1, j-1]
                if i &gt; 0:
                        possible_moves[1] = dtw_cost[i-1, j]
                if j &gt; 0:
                        possible_moves[2] = dtw_cost[i, j-1]
                best_move = _np.argmin(possible_moves)
                if best_move == 0:
                        i -= 1
                        j -= 1
                elif best_move == 1:
                        i -= 1
                else:
                        j -= 1
        dtw_path[0].append(0)
        return dtw_cost[-1, -1], dtw_path</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="eyekit.drift.attach"><code class="name flex">
<span>def <span class="ident">attach</span></span>(<span>fixation_XY, line_Y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attach(fixation_XY, line_Y):
        n = len(fixation_XY)
        for fixation_i in range(n):
                line_i = _np.argmin(abs(line_Y - fixation_XY[fixation_i, 1]))
                fixation_XY[fixation_i, 1] = line_Y[line_i]
        return fixation_XY</code></pre>
</details>
</dd>
<dt id="eyekit.drift.chain"><code class="name flex">
<span>def <span class="ident">chain</span></span>(<span>fixation_XY, line_Y, x_thresh=192, y_thresh=32)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chain(fixation_XY, line_Y, x_thresh=192, y_thresh=32):
        n = len(fixation_XY)
        dist_X = abs(_np.diff(fixation_XY[:, 0]))
        dist_Y = abs(_np.diff(fixation_XY[:, 1]))
        end_chain_indices = list(_np.where(_np.logical_or(dist_X &gt; x_thresh, dist_Y &gt; y_thresh))[0] + 1)
        end_chain_indices.append(n)
        start_of_chain = 0
        for end_of_chain in end_chain_indices:
                mean_y = _np.mean(fixation_XY[start_of_chain:end_of_chain, 1])
                line_i = _np.argmin(abs(line_Y - mean_y))
                fixation_XY[start_of_chain:end_of_chain, 1] = line_Y[line_i]
                start_of_chain = end_of_chain
        return fixation_XY</code></pre>
</details>
</dd>
<dt id="eyekit.drift.cluster"><code class="name flex">
<span>def <span class="ident">cluster</span></span>(<span>fixation_XY, line_Y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster(fixation_XY, line_Y):
        try:
                from sklearn.cluster import KMeans
        except ImportError:
                raise ImportError(&#39;The cluster method requires sklean. pip install sklearn&#39;)
        m = len(line_Y)
        fixation_Y = fixation_XY[:, 1].reshape(-1, 1)
        clusters = KMeans(m, n_init=100, max_iter=300).fit_predict(fixation_Y)
        centers = [fixation_Y[clusters == i].mean() for i in range(m)]
        ordered_cluster_indices = _np.argsort(centers)
        for fixation_i, cluster_i in enumerate(clusters):
                line_i = _np.where(ordered_cluster_indices == cluster_i)[0][0]
                fixation_XY[fixation_i, 1] = line_Y[line_i]
        return fixation_XY</code></pre>
</details>
</dd>
<dt id="eyekit.drift.dynamic_time_warping"><code class="name flex">
<span>def <span class="ident">dynamic_time_warping</span></span>(<span>sequence1, sequence2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamic_time_warping(sequence1, sequence2):
        n1 = len(sequence1)
        n2 = len(sequence2)
        dtw_cost = _np.zeros((n1+1, n2+1))
        dtw_cost[0, :] = _np.inf
        dtw_cost[:, 0] = _np.inf
        dtw_cost[0, 0] = 0
        for i in range(n1):
                for j in range(n2):
                        this_cost = _np.sqrt(sum((sequence1[i] - sequence2[j])**2))
                        dtw_cost[i+1, j+1] = this_cost + min(dtw_cost[i, j+1], dtw_cost[i+1, j], dtw_cost[i, j])
        dtw_cost = dtw_cost[1:, 1:]
        dtw_path = [[] for _ in range(n1)]
        while i &gt; 0 or j &gt; 0:
                dtw_path[i].append(j)
                possible_moves = [_np.inf, _np.inf, _np.inf]
                if i &gt; 0 and j &gt; 0:
                        possible_moves[0] = dtw_cost[i-1, j-1]
                if i &gt; 0:
                        possible_moves[1] = dtw_cost[i-1, j]
                if j &gt; 0:
                        possible_moves[2] = dtw_cost[i, j-1]
                best_move = _np.argmin(possible_moves)
                if best_move == 0:
                        i -= 1
                        j -= 1
                elif best_move == 1:
                        i -= 1
                else:
                        j -= 1
        dtw_path[0].append(0)
        return dtw_cost[-1, -1], dtw_path</code></pre>
</details>
</dd>
<dt id="eyekit.drift.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>fixation_XY, line_Y, y_thresh=32, g_thresh=0.1, e_thresh=20)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(fixation_XY, line_Y, y_thresh=32, g_thresh=0.1, e_thresh=20):
        n = len(fixation_XY)
        m = len(line_Y)
        diff_X = _np.diff(fixation_XY[:, 0])
        dist_Y = abs(_np.diff(fixation_XY[:, 1]))
        sequence_boundaries = list(_np.where(_np.logical_or(diff_X &lt; 0, dist_Y &gt; y_thresh))[0] + 1)
        sequence_starts = [0] + sequence_boundaries
        sequence_ends = sequence_boundaries + [n]
        sequences = [list(range(start, end)) for start, end in zip(sequence_starts, sequence_ends)]
        for phase in phases:
                while len(sequences) &gt; m:
                        best_merger = None
                        best_error = _np.inf
                        for i in range(len(sequences)-1):
                                if len(sequences[i]) &lt; phase[&#39;min_i&#39;]:
                                        continue # first sequence too short, skip to next i
                                for j in range(i+1, len(sequences)):
                                        if len(sequences[j]) &lt; phase[&#39;min_j&#39;]:
                                                continue # second sequence too short, skip to next j
                                        candidate_XY = fixation_XY[sequences[i] + sequences[j]]
                                        gradient, intercept = _np.polyfit(candidate_XY[:, 0], candidate_XY[:, 1], 1)
                                        residuals = candidate_XY[:, 1] - (gradient * candidate_XY[:, 0] + intercept)
                                        error = _np.sqrt(sum(residuals**2) / len(candidate_XY))
                                        if phase[&#39;no_constraints&#39;] or (abs(gradient) &lt; g_thresh and error &lt; e_thresh):
                                                if error &lt; best_error:
                                                        best_merger = (i, j)
                                                        best_error = error
                        if best_merger is None:
                                break # no possible mergers, break while and move to next phase
                        merge_i, merge_j = best_merger
                        merged_sequence = sequences[merge_i] + sequences[merge_j]
                        sequences.append(merged_sequence)
                        del sequences[merge_j], sequences[merge_i]
        mean_Y = [fixation_XY[sequence, 1].mean() for sequence in sequences]
        ordered_sequence_indices = _np.argsort(mean_Y)
        for line_i, sequence_i in enumerate(ordered_sequence_indices):
                fixation_XY[sequences[sequence_i], 1] = line_Y[line_i]
        return fixation_XY</code></pre>
</details>
</dd>
<dt id="eyekit.drift.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>values)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(values):
        values = list(values)
        return max(set(values), key=values.count)</code></pre>
</details>
</dd>
<dt id="eyekit.drift.regress"><code class="name flex">
<span>def <span class="ident">regress</span></span>(<span>fixation_XY, line_Y, k_bounds=(-0.1, 0.1), o_bounds=(-50, 50), s_bounds=(1, 20))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regress(fixation_XY, line_Y, k_bounds=(-0.1, 0.1), o_bounds=(-50, 50), s_bounds=(1, 20)):
        try:
                from scipy.optimize import minimize
                from scipy.stats import norm
        except ImportError:
                raise ImportError(&#39;The regress method requires scipy. pip install scipy&#39;)
        n = len(fixation_XY)
        m = len(line_Y)

        def fit_lines(params, return_line_assignments=False):
                k = k_bounds[0] + (k_bounds[1] - k_bounds[0]) * norm.cdf(params[0])
                o = o_bounds[0] + (o_bounds[1] - o_bounds[0]) * norm.cdf(params[1])
                s = s_bounds[0] + (s_bounds[1] - s_bounds[0]) * norm.cdf(params[2])
                predicted_Y_from_slope = fixation_XY[:, 0] * k
                line_Y_plus_offset = line_Y + o
                density = _np.zeros((n, m))
                for line_i in range(m):
                        fit_Y = predicted_Y_from_slope + line_Y_plus_offset[line_i]
                        density[:, line_i] = norm.logpdf(fixation_XY[:, 1], fit_Y, s)
                if return_line_assignments:
                        return density.argmax(axis=1)
                return -sum(density.max(axis=1))

        best_fit = minimize(fit_lines, [0, 0, 0])
        line_assignments = fit_lines(best_fit.x, True)
        for fixation_i, line_i in enumerate(line_assignments):
                fixation_XY[fixation_i, 1] = line_Y[line_i]
        return fixation_XY</code></pre>
</details>
</dd>
<dt id="eyekit.drift.segment"><code class="name flex">
<span>def <span class="ident">segment</span></span>(<span>fixation_XY, line_Y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment(fixation_XY, line_Y):
        n = len(fixation_XY)
        m = len(line_Y)
        diff_X = _np.diff(fixation_XY[:, 0])
        saccades_ordered_by_length = _np.argsort(diff_X)
        line_change_indices = saccades_ordered_by_length[:m-1]
        current_line_i = 0
        for fixation_i in range(n):
                fixation_XY[fixation_i, 1] = line_Y[current_line_i]
                if fixation_i in line_change_indices:
                        current_line_i += 1
        return fixation_XY</code></pre>
</details>
</dd>
<dt id="eyekit.drift.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>fixation_XY, line_Y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(fixation_XY, line_Y):
        n = len(fixation_XY)
        diff_X = _np.diff(fixation_XY[:, 0])
        clusters = KMeans(2, n_init=10, max_iter=300).fit_predict(diff_X.reshape(-1, 1))
        centers = [diff_X[clusters == 0].mean(), diff_X[clusters == 1].mean()]
        sweep_marker = _np.argmin(centers)
        end_line_indices = list(_np.where(clusters == sweep_marker)[0] + 1)
        end_line_indices.append(n)
        start_of_line = 0
        for end_of_line in end_line_indices:
                mean_y = _np.mean(fixation_XY[start_of_line:end_of_line, 1])
                line_i = _np.argmin(abs(line_Y - mean_y))
                fixation_XY[start_of_line:end_of_line, 1] = line_Y[line_i]
                start_of_line = end_of_line
        return fixation_XY</code></pre>
</details>
</dd>
<dt id="eyekit.drift.warp"><code class="name flex">
<span>def <span class="ident">warp</span></span>(<span>fixation_XY, word_XY)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def warp(fixation_XY, word_XY):
        _, dtw_path = dynamic_time_warping(fixation_XY, word_XY)
        for fixation_i, words_mapped_to_fixation_i in enumerate(dtw_path):
                candidate_Y = word_XY[words_mapped_to_fixation_i, 1]
                fixation_XY[fixation_i, 1] = mode(candidate_Y)
        return fixation_XY</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eyekit" href="index.html">eyekit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="eyekit.drift.attach" href="#eyekit.drift.attach">attach</a></code></li>
<li><code><a title="eyekit.drift.chain" href="#eyekit.drift.chain">chain</a></code></li>
<li><code><a title="eyekit.drift.cluster" href="#eyekit.drift.cluster">cluster</a></code></li>
<li><code><a title="eyekit.drift.dynamic_time_warping" href="#eyekit.drift.dynamic_time_warping">dynamic_time_warping</a></code></li>
<li><code><a title="eyekit.drift.merge" href="#eyekit.drift.merge">merge</a></code></li>
<li><code><a title="eyekit.drift.mode" href="#eyekit.drift.mode">mode</a></code></li>
<li><code><a title="eyekit.drift.regress" href="#eyekit.drift.regress">regress</a></code></li>
<li><code><a title="eyekit.drift.segment" href="#eyekit.drift.segment">segment</a></code></li>
<li><code><a title="eyekit.drift.split" href="#eyekit.drift.split">split</a></code></li>
<li><code><a title="eyekit.drift.warp" href="#eyekit.drift.warp">warp</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>