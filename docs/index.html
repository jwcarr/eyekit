<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>eyekit API documentation</title>
<meta name="description" content="Eyekit is a lightweight Python package for doing open,
transparent, reproducible science on reading behavior. Eyekit is
entirely independent of any â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:0.8em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/227875615/00ca2d80-f76c-11ea-807f-d81cd315b9df"/>
<meta name="twitter:site" content="@github"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:title" content="eyekit"/>
<meta name="twitter:description" content="A lightweight Python package for doing open, transparent, reproducible science on reading behavior"/>
<meta property="og:image" content="https://repository-images.githubusercontent.com/227875615/00ca2d80-f76c-11ea-807f-d81cd315b9df"/>
<meta property="og:site_name" content="GitHub"/>
<meta property="og:type" content="object"/>
<meta property="og:title" content="eyekit"/>
<meta property="og:url" content="https://github.com/jwcarr/eyekit"/>
<meta property="og:description" content="A lightweight Python package for doing open, transparent, reproducible science on reading behavior"/>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>eyekit</code></h1>
</header>
<section id="section-intro">
<p>Eyekit is a lightweight Python package for doing open,
transparent, reproducible science on reading behavior. Eyekit is
entirely independent of any particular eyetracker hardware,
presentation software, or data formats, and has a minimal set of
dependencies. It has an object-oriented style that defines two core
objects â€“ the TextBlock and the FixationSequence â€“ that you bring into
contact with a bit of coding. Eyekit is currently in the pre-alpha
stage and is licensed under the terms of the MIT License.</p>
<h2 id="is-eyekit-the-right-tool-for-me">Is Eyekit the Right Tool for Me?</h2>
<ul>
<li>
<p>You basically just want to analyze which parts of a text someone is looking at by defining areas of interest.</p>
</li>
<li>
<p>You are interested in a fixation-level analysis, as opposed to, for example, saccades or millisecond-by-millisecond eye movements.</p>
</li>
<li>
<p>You don't mind doing a little bit of legwork to transform your raw fixation data and texts into something Eyekit can understand.</p>
</li>
<li>
<p>You need support for arbitrary fonts that may be monospaced or proportional.</p>
</li>
<li>
<p>You want the flexibility to define custom measures and to build your own reproducible processing pipeline.</p>
</li>
<li>
<p>You would like tools for dealing with noise and calibration issues, such as vertical drift, and for discarding fixations according to your own criteria.</p>
</li>
<li>
<p>You want to produce publication-ready visualizations and to share your data in a standard and open format.</p>
</li>
</ul>
<h2 id="installation">Installation</h2>
<p>The latest version of Eyekit can be installed using <code>pip</code>:</p>
<pre><code class="shell">$ pip install eyekit
</code></pre>
<p>Eyekit is compatible with Python 3.6 and up and has four dependencies:</p>
<ul>
<li><a href="https://numpy.org">NumPy</a></li>
<li><a href="https://matplotlib.org">matplotlib</a></li>
<li><a href="https://pypi.org/project/fonttools/">fontTools</a></li>
<li><a href="https://cairosvg.org">CairoSVG</a></li>
</ul>
<p><a href="https://www.scipy.org">SciPy</a> and <a href="https://scikit-learn.org">scikit-learn</a> are required by certain tools but can be installed later if needed.</p>
<h2 id="getting-started">Getting Started</h2>
<p>Once installed, import Eyekit in the normal way:</p>
<pre><code class="python">&gt;&gt;&gt; import eyekit
</code></pre>
<p>Eyekit makes use of two core objects: the <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> and the <code><a title="eyekit.fixation.FixationSequence" href="fixation.html#eyekit.fixation.FixationSequence">FixationSequence</a></code>. Much of Eyekit's functionality involves bringing these two objects into contact. Typically, you define particular areas of the <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> that are of interest (phrases, words, morphemes, letters&hellip;) and check to see which fixations from the <code><a title="eyekit.fixation.FixationSequence" href="fixation.html#eyekit.fixation.FixationSequence">FixationSequence</a></code> fall in those areas and for how long.</p>
<h3 id="the-textblock-object">The TextBlock object</h3>
<p>A <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> can represent a word, sentence, or passage of text. When you create a <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> object, it is necessary to specify the pixel position of the top-left corner, the font, and the font size. Optionally, you can also specify the line spacing (1 for single line spacing, 2 for double line spacing, etc.). Let's begin by creating a <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> representing a single sentence:</p>
<pre><code class="python">&gt;&gt;&gt; sentence = 'The quick brown fox [jump]{stem_1}[ed]{suffix_1} over the lazy dog.'
&gt;&gt;&gt; txt = eyekit.TextBlock(sentence, position=(100, 500), font_name='Times New Roman', font_size=36)
&gt;&gt;&gt; print(txt)
### TextBlock[The quick brown ...]
</code></pre>
<p>Eyekit has a simple scheme for marking up interest areas, as you can see in the above sentence. Square brackets are used to mark the interest area itself (in this case <em>jump</em> and <em>ed</em>) and curly braces are used to provide a unique label for each interest area (in this case <code>stem_1</code> and <code>suffix_1</code>). These interest areas that have been specifically marked up in the raw text are called "zones". We can iterate over the zones using the <code><a title="eyekit.text.TextBlock.zones" href="text.html#eyekit.text.TextBlock.zones">TextBlock.zones()</a></code> iterator:</p>
<pre><code class="python">&gt;&gt;&gt; for zone in txt.zones():
&gt;&gt;&gt;     print(zone.label, zone.text, zone.box)
### stem_1 jump (411.923828125, 500.0, 74.00390625, 36.0)
### suffix_1 ed (485.927734375, 500.0, 33.978515625, 36.0)
</code></pre>
<p>In this case, we are printing each zone's label, the string of text it represents, and its bounding box (x, y, width, and height). In addition to manually marked-up zones, you can also create interest areas automatically based on the lines, words, characters, or ngrams of the text. If, for example, you were interested in all words, you could use <code><a title="eyekit.text.TextBlock.words" href="text.html#eyekit.text.TextBlock.words">TextBlock.words()</a></code> to iterate over every word as an interest area without needing to explicitly mark them up in the raw text:</p>
<pre><code class="python">&gt;&gt;&gt; for word in txt.words():
&gt;&gt;&gt;     print(word.label, word.text, word.box)
### word_0 The (95.5, 500.0, 64.96875, 36.0)
### word_1 quick (160.46875, 500.0, 88.98046875, 36.0)
### word_2 brown (249.44921875, 500.0, 100.986328125, 36.0)
### word_3 fox (350.435546875, 500.0, 56.98828125, 36.0)
### word_4 jumped (407.423828125, 500.0, 116.982421875, 36.0)
### word_5 over (524.40625, 500.0, 72.966796875, 36.0)
### word_6 the (597.373046875, 500.0, 52.98046875, 36.0)
### word_7 lazy (650.353515625, 500.0, 68.958984375, 36.0)
### word_8 dog (719.3125, 500.0, 63.0, 36.0)
</code></pre>
<p>You can also slice out arbitrary interest areas by using the row and column indices of a section of text. Here, for example, we are taking a slice from row 0 (the first and only line) and characters 10 through 18:</p>
<pre><code class="python">&gt;&gt;&gt; arbitrary_slice = txt[0, 10:19]
&gt;&gt;&gt; print(arbitrary_slice.text, arbitrary_slice.box)
### brown fox (253.94921875, 500.0, 148.974609375, 36.0)
</code></pre>
<p>This could be useful if you wanted to slice up the text in some programmatic way, creating interest areas from each three-letter chunk, for example.</p>
<h3 id="the-fixationsequence-object">The FixationSequence object</h3>
<p>Fixation data is represented in a <code><a title="eyekit.fixation.FixationSequence" href="fixation.html#eyekit.fixation.FixationSequence">FixationSequence</a></code> object. Let's create some pretend data to play around with:</p>
<pre><code class="python">&gt;&gt;&gt; seq = eyekit.FixationSequence([[106, 520, 100], [190, 516, 100], [230, 535, 100], [298, 520, 100], [361, 527, 100], [430, 519, 100], [450, 535, 100], [492, 521, 100], [562, 535, 100], [637, 523, 100], [712, 517, 100], [763, 517, 100]])
</code></pre>
<p>Each fixation is represented by three numbers: its x-coordinate, its y-coordinate, and its duration (in this example, they're all 100ms). Once created, a <code><a title="eyekit.fixation.FixationSequence" href="fixation.html#eyekit.fixation.FixationSequence">FixationSequence</a></code> can be traversed, indexed, and sliced as you'd expect. For example,</p>
<pre><code class="python">&gt;&gt;&gt; print(seq[5:10])
### FixationSequence[Fixation[430,519], ..., Fixation[637,523]]
</code></pre>
<p>slices out fixations 5 through 9 into a new <code><a title="eyekit.fixation.FixationSequence" href="fixation.html#eyekit.fixation.FixationSequence">FixationSequence</a></code> object. This could be useful, for example, if you wanted to remove superfluous fixations from the start and end of the sequence.</p>
<p>A basic question we might have at this point is: Do any of these fixations fall inside the zones I marked up? We can write some simple code to answer this, using one of the <code>which_</code> methods:</p>
<pre><code class="python">&gt;&gt;&gt; for fixation in seq:
&gt;&gt;&gt;     zone = txt.which_zone(fixation)
&gt;&gt;&gt;     if zone is not None:
&gt;&gt;&gt;         print(f'There was a fixation inside {zone.label}, which is &quot;{zone.text}&quot;.')
### There was a fixation inside stem_1, which is &quot;jump&quot;.
### There was a fixation inside stem_1, which is &quot;jump&quot;.
### There was a fixation inside suffix_1, which is &quot;ed&quot;.
</code></pre>
<h2 id="analysis">Analysis</h2>
<p>At the moment, Eyekit has a fairly limited set of analysis functions; in general, you are expected to write code to calculate whatever you are interested in measuring. The functions that are currently available can be explored in the <code><a title="eyekit.analysis" href="analysis.html">eyekit.analysis</a></code> module, but two common eyetracking measures that <em>are</em> implemented are <code><a title="eyekit.analysis.initial_fixation_duration" href="analysis.html#eyekit.analysis.initial_fixation_duration">initial_fixation_duration()</a></code> and <code><a title="eyekit.analysis.total_fixation_duration" href="analysis.html#eyekit.analysis.total_fixation_duration">total_fixation_duration()</a></code>, which may be used like this:</p>
<pre><code class="python">&gt;&gt;&gt; tot_durations = eyekit.analysis.total_fixation_duration(txt.zones(), seq)
&gt;&gt;&gt; print(tot_durations)
### {'stem_1': 200, 'suffix_1': 100}
&gt;&gt;&gt; init_durations = eyekit.analysis.initial_fixation_duration(txt.zones(), seq)
&gt;&gt;&gt; print(init_durations)
### {'stem_1': 100, 'suffix_1': 100}
</code></pre>
<p>In this case, we see that the total time spent inside the <code>stem_1</code> interest area was 200ms, while the duration of the initial fixation on that interest area was 100ms. Similarly, these analysis functions can be applied to other kinds of interest areas, such as words:</p>
<pre><code class="python">&gt;&gt;&gt; tot_durations_on_words = eyekit.analysis.total_fixation_duration(txt.words(), seq)
&gt;&gt;&gt; print(tot_durations_on_words)
### {'word_0': 100, 'word_1': 200, 'word_2': 100, 'word_3': 100, 'word_4': 300, 'word_5': 100, 'word_6': 100, 'word_7': 100, 'word_8': 100}
</code></pre>
<p>Here we see that a total of 300ms was spent on <code>word_4</code>, "jumped".</p>
<h2 id="visualization">Visualization</h2>
<p>Eyekit has some basic tools to help you create visualizations of your data. We begin by creating an <code><a title="eyekit.image.Image" href="image.html#eyekit.image.Image">Image</a></code> object, specifying the pixel dimensions of the screen:</p>
<pre><code class="python">&gt;&gt;&gt; img = eyekit.Image(1920, 1080)
</code></pre>
<p>Next we render our text and fixations:</p>
<pre><code class="python">&gt;&gt;&gt; img.render_text(txt)
&gt;&gt;&gt; img.render_fixations(seq)
</code></pre>
<p>Note that the elements of the image will be layered in the order in which these methods are called â€“ in this case, the fixations will be rendered on top of the text. Finally, we save the image. Eyekit natively creates images in the SVG format, but the images can be converted to PDF, EPS, or PNG on the fly by using the appropriate file extension:</p>
<pre><code class="python">&gt;&gt;&gt; img.save('quick_brown.pdf')
</code></pre>
<p><img src='./quick_brown.svg'></p>
<p>Sometimes it's useful to see the text in the context of the entire screen, as is the case here; other times, we'd like to remove all that excess white space and focus in on the text. To do this, you can call the <code>crop_to_text()</code> method prior to saving, optionally specifying some amount of margin:</p>
<pre><code class="python">&gt;&gt;&gt; img.crop_to_text(margin=5)
&gt;&gt;&gt; img.save('quick_brown_cropped.pdf')
</code></pre>
<p><img src='./quick_brown_cropped.svg'></p>
<p>There are many other options for creating custom visualizations, which you can explore in the <code><a title="eyekit.image" href="image.html">eyekit.image</a></code> module. For example, if you wanted to depict the bounding boxes around the two zoned interest areas we defined earlier, with different colors for stems and suffixes, you might do this:</p>
<pre><code class="python">&gt;&gt;&gt; img = eyekit.Image(1920, 1080)
&gt;&gt;&gt; img.render_text(txt)
&gt;&gt;&gt; for zone in txt.zones():
&gt;&gt;&gt;     if zone.label.startswith('stem'):
&gt;&gt;&gt;         img.draw_rectangle(zone.bounding_box, color='red')
&gt;&gt;&gt;     elif zone.label.startswith('suffix'):
&gt;&gt;&gt;         img.draw_rectangle(zone.bounding_box, color='blue')
&gt;&gt;&gt; img.render_fixations(seq)
&gt;&gt;&gt; img.crop_to_text(margin=5)
&gt;&gt;&gt; img.save('quick_brown_with_IAs.pdf')
</code></pre>
<p><img src='./quick_brown_with_IAs.svg'></p>
<h2 id="multiline-passages">Multiline Passages</h2>
<p>So far, we've only looked at a single line <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code>, but handling multiline passages works in largely the same way. The principal difference is that when you instantiate your <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> object, you must pass a <em>list</em> of strings (one for each line of text):</p>
<pre><code class="python">&gt;&gt;&gt; txt = eyekit.TextBlock(['This is line 1', 'This is line 2'], position=(100, 500), font_name='Arial', font_size=24)
</code></pre>
<p>To see an example, we'll load in some real multiline passage data from <a href="https://osf.io/hx2sj/">Pescuma et al.</a> which is included in the <a href="https://github.com/jwcarr/eyekit">GitHub repository</a>:</p>
<pre><code class="python">&gt;&gt;&gt; example_data = eyekit.io.read('example/example_data.json')
&gt;&gt;&gt; example_texts = eyekit.io.read('example/example_texts.json')
</code></pre>
<p>and in particular we'll extract the fixation sequence for trial 0 and its associated text:</p>
<pre><code class="python">&gt;&gt;&gt; seq = example_data['trial_0']['fixations']
&gt;&gt;&gt; pid = example_data['trial_0']['passage_id']
&gt;&gt;&gt; txt = example_texts[pid]['text']
</code></pre>
<p>As before, we can plot the fixation sequence over the passage of text to see what the data looks like:</p>
<pre><code class="python">&gt;&gt;&gt; img = eyekit.Image(1920, 1080)
&gt;&gt;&gt; img.render_text(txt)
&gt;&gt;&gt; img.draw_rectangle(txt[0, 32:40].box, color='orange')
&gt;&gt;&gt; img.draw_rectangle(txt[4, 12:17].box, color='orange')
&gt;&gt;&gt; img.render_fixations(seq)
&gt;&gt;&gt; img.crop_to_text(margin=50)
&gt;&gt;&gt; img.save('multiline_passage.pdf')
</code></pre>
<p><img src='./multiline_passage.svg'></p>
<p>A common issue with multiline passage reading is that fixations on one line may appear closer to another line due to imperfect eyetracker calibration or general noise. For example, the fixation on "voce" on line two actually falls into the bounding box of the word "vivevano" on line one. Likewise, the fixation on "passeggiata" in the middle of the text is closer to "Mamma" on the line above. Obviously, such "vertical drift" will cause issues in your analysis further downstream, so it may be useful to first clean up the data by snapping every fixation to its appropriate line. Eyekit implements several vertical drift correction algorithms, which can be applied using the <code><a title="eyekit.tools.snap_to_lines" href="tools.html#eyekit.tools.snap_to_lines">snap_to_lines()</a></code> function from the <code><a title="eyekit.tools" href="tools.html">eyekit.tools</a></code> module:</p>
<pre><code class="python">&gt;&gt;&gt; clean_seq = eyekit.tools.snap_to_lines(seq, txt, method='warp')
</code></pre>
<p>This process only affects the y-coordinate of each fixation; the x-coordinate is always left unchanged. The default method is <code>warp</code>, but you can also use <code>chain</code>, <code>cluster</code>, <code>merge</code>, <code>regress</code>, <code>segment</code>, and <code>split</code>. For a full description and evaluation of these methods, see <a href="https://osf.io/jg3nc/">Carr et al. (2020)</a>. Let's have a look at the fixation sequence after applying this cleaning step:</p>
<pre><code class="python">&gt;&gt;&gt; img = eyekit.Image(1920, 1080)
&gt;&gt;&gt; img.render_text(txt)
&gt;&gt;&gt; img.render_fixations(clean_seq)
&gt;&gt;&gt; img.crop_to_text(50)
&gt;&gt;&gt; img.save('multiline_passage_corrected.pdf')
</code></pre>
<p><img src='./multiline_passage_corrected.svg'></p>
<p>The fixations on "voce" and "passeggiata", for example, are now clearly associated with the correct words, allowing us to proceed with our analysis. It is important to note, however, that drift correction should be applied with care, especially if the fixation data is very noisy or if the passage is being read nonlinearly.</p>
<p>Just as with single-line texts, we can iterate over lines, words, characters, and ngrams using the appropriate methods and apply the same kinds of analysis functions. For example, if we were interested in the word "piccolo"/"piccola" in this passage, we could do this:</p>
<pre><code class="python">&gt;&gt;&gt; piccol_zones = list(txt.words('piccol[oa]'))
&gt;&gt;&gt; tot_durations = eyekit.analysis.total_fixation_duration(piccol_zones, clean_seq)
&gt;&gt;&gt; img = eyekit.Image(1920, 1080)
&gt;&gt;&gt; img.render_text(txt)
&gt;&gt;&gt; img.render_fixations(clean_seq, color='gray')
&gt;&gt;&gt; for word in piccol_zones:
&gt;&gt;&gt;   img.draw_rectangle(word.box, color='green')
&gt;&gt;&gt;   duration = tot_durations[word.label]
&gt;&gt;&gt;   img.draw_text(f'{duration}ms', word.x_br, word.y_br, color='green', style={'font-family':'Arial', 'font-weight':'bold', 'font-size':20})
&gt;&gt;&gt; img.crop_to_text(50)
&gt;&gt;&gt; img.save('multiline_passage_piccol.pdf')
</code></pre>
<p><img src='./multiline_passage_piccol.svg'></p>
<h2 id="inputoutput">Inputâ€“Output</h2>
<p>Eyekit is not especially committed to any particular file format; so long as you have an x-coordinate, a y-coordinate, and a duration for each fixation, you are free to store data in whatever format you choose. However, as we have seen briefly above, Eyekit provides built-in support for JSON, where a typical data file might look somthing like this:</p>
<pre><code class="json">{
  &quot;trial_0&quot; : {
    &quot;participant_id&quot;: &quot;John&quot;,
    &quot;passage_id&quot;: &quot;passage_a&quot;,
    &quot;fixations&quot;: { &quot;__FixationSequence__&quot; : [[412, 142, 131], ..., [588, 866, 224]] }
  },
  &quot;trial_1&quot; : {
    &quot;participant_id&quot;: &quot;Mary&quot;,
    &quot;passage_id&quot;: &quot;passage_b&quot;,
    &quot;fixations&quot;: { &quot;__FixationSequence__&quot; : [[368, 146, 191], ..., [725, 681, 930]] }
  },
  &quot;trial_2&quot; : {
    &quot;participant_id&quot;: &quot;Jack&quot;,
    &quot;passage_id&quot;: &quot;passage_c&quot;,
    &quot;fixations&quot;: { &quot;__FixationSequence__&quot; : [[374, 147, 277], ..., [1288, 804, 141]] }
  }
}
</code></pre>
<p>This format is open, human-readable, and flexible. With the exception of the <code>__FixationSequence__</code> object, you can freely store whatever key-value pairs you want and you can organize the hierarchy of the data structure in any way that makes sense for your project. JSON files can be loaded using the <code><a title="eyekit.io.read" href="io.html#eyekit.io.read">read()</a></code> function from the <code><a title="eyekit.io" href="io.html">eyekit.io</a></code> module:</p>
<pre><code class="python">&gt;&gt;&gt; data = eyekit.io.read('example/example_data.json')
&gt;&gt;&gt; print(data)
### {'trial_0': {'participant_id': 'John', 'passage_id': 'passage_a', 'fixations': FixationSequence[Fixation[412,142], ..., Fixation[588,866]]}, 'trial_1': {'participant_id': 'Mary', 'passage_id': 'passage_b', 'fixations': FixationSequence[Fixation[368,146], ..., Fixation[725,681]]}, 'trial_2': {'participant_id': 'Jack', 'passage_id': 'passage_c', 'fixations': FixationSequence[Fixation[374,147], ..., Fixation[1288,804]]}}
</code></pre>
<p>which automatically instantiates any <code><a title="eyekit.fixation.FixationSequence" href="fixation.html#eyekit.fixation.FixationSequence">FixationSequence</a></code> objects. Similarly, an arbitrary dictionary of data can be written out using the <code><a title="eyekit.io.write" href="io.html#eyekit.io.write">write()</a></code> function:</p>
<pre><code class="python">&gt;&gt;&gt; eyekit.io.write(data, 'output_data.json', compress=True)
</code></pre>
<p>If <code>compress</code> is set to <code>True</code> (the default), files are written in the most compact way; if <code>False</code>, the file will be larger but more human-readable (like the example above). JSON can also be used to store <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> objects â€“ see <code>example_texts.json</code> for an example â€“ and you can even store <code><a title="eyekit.fixation.FixationSequence" href="fixation.html#eyekit.fixation.FixationSequence">FixationSequence</a></code> and <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> objects in the same file if you like to keep things together.</p>
<h2 id="getting-your-data-into-eyekit">Getting Your Data Into Eyekit</h2>
<p>Currently, the options for converting your raw data into something Eyekit can understand are quite limited. In time, I hope to add more functions that convert from common formats.</p>
<h3 id="fixation-data">Fixation data</h3>
<p>If you have your fixation data in CSV files, you could load the data into a <code><a title="eyekit.fixation.FixationSequence" href="fixation.html#eyekit.fixation.FixationSequence">FixationSequence</a></code> by doing something along these lines (assuming you have columns <code>x</code>, <code>y</code>, and <code>duration</code>):</p>
<pre><code class="python">&gt;&gt;&gt; import pandas
&gt;&gt;&gt; data = pandas.read_csv('mydata.csv')
&gt;&gt;&gt; fixations = [fxn for fxn in zip(data['x'], data['y'], data['duration'])]
&gt;&gt;&gt; seq = eyekit.FixationSequence(fixations)
</code></pre>
<p>Eyekit has rudimentary support for importing data from ASC files. When importing data this way, you must specify the name of a trial variable and its possible values so that the importer can determine when a new trial begins:</p>
<pre><code class="python">&gt;&gt;&gt; data = eyekit.io.import_asc('mydata.asc', 'trial_type', ['Experimental'], extract_vars=['passage_id', 'response'])
</code></pre>
<p>In this case, when parsing the ASC file, the importer would consider</p>
<pre><code class="plaintext">MSG 4244100 !V TRIAL_VAR trial_type Experimental
</code></pre>
<p>to mark the beginning of a new trial and will extract all <code>EFIX</code> lines that occur within the subsequent <code>START</code>â€“<code>END</code> block. Optionally, you can specify other variables that you want to extract (in this case <code>passage_id</code> and <code>response</code>), resulting in imported data that looks like this:</p>
<pre><code class="python">{
  &quot;trial_0&quot; : {
    &quot;trial_type&quot; : &quot;Experimental&quot;,
    &quot;passage_id&quot; : &quot;passage_a&quot;,
    &quot;response&quot; : &quot;yes&quot;,
    &quot;fixations&quot; : FixationSequence[[368, 161, 208], ..., [562, 924, 115]]
  }
}
</code></pre>
<p>In addition, rather than load one ASC file at a time, you can also point to a directory of ASC files, all of which will then be loaded into a single dataset:</p>
<pre><code class="python">&gt;&gt;&gt; data = eyekit.io.import_asc('asc_data_files/', 'trial_type', ['Experimental'], extract_variables=['passage_id', 'response'])
</code></pre>
<p>which could then be written out to Eyekit's native format for quick access in the future:</p>
<pre><code class="python">&gt;&gt;&gt; eyekit.io.write(data, 'converted_asc_data.json')
</code></pre>
<h3 id="text-data">Text data</h3>
<p>Getting texts into Eyekit can be a little tricky because their precise layout will be highly dependent on many different factors â€“ not just the font and fontsize, but also the presentation software and its text rendering engine, the size and resolution of the display, the positioning of the text, and perhaps even the operating system itself.</p>
<p>Ideally, all of your texts will be presented so that the top-left corner of the block of text is located in a consistent position on the screen (depending on how you set up your experiment, this may already be the case). Eyekit uses this position to figure out the precise location of characters and interest areas based on the particular font and font size you are using. However, this process is somewhat imperfect and you might need to experiment a little to get up and running. The best way to do this is to create a <code><a title="eyekit.text.TextBlock" href="text.html#eyekit.text.TextBlock">TextBlock</a></code> with values that seem to make sense and then output a PNG image, which will have the exact pixel dimensions of the screen; you can then check that this image matches up with a screenshot of what your participants are actually seeing.</p>
<div class="git-link-div"><a href="https://github.com/jwcarr/eyekit/blob/e3bebf4201bc482ee24715c1a1573d52edcb650e/eyekit/__init__.py#L0-L25" class="git-link">View code on GitHub</a></div>
</section>
<section>
<h2 class="section-title" id="header-submodules">Documentation</h2>
<dl>
<dt><code class="name"><a title="eyekit.analysis" href="analysis.html">eyekit.analysis</a></code></dt>
<dd>
<div class="desc"><p>Functions for calculating common analysis measures, such as total
fixation duration or initial landing position.</p></div>
</dd>
<dt><code class="name"><a title="eyekit.fixation" href="fixation.html">eyekit.fixation</a></code></dt>
<dd>
<div class="desc"><p>Defines classes for dealing with fixations, most notably the
<code>FixationSequence</code> object.</p></div>
</dd>
<dt><code class="name"><a title="eyekit.image" href="image.html">eyekit.image</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code>Image</code> object, which is used to create visualizations,
and other functions for handling images.</p></div>
</dd>
<dt><code class="name"><a title="eyekit.io" href="io.html">eyekit.io</a></code></dt>
<dd>
<div class="desc"><p>Functions for reading and writing data.</p></div>
</dd>
<dt><code class="name"><a title="eyekit.text" href="text.html">eyekit.text</a></code></dt>
<dd>
<div class="desc"><p>Defines classes for dealing with texts, most notably the
<code>TextBlock</code> and <code>InterestArea</code> objects.</p></div>
</dd>
<dt><code class="name"><a title="eyekit.tools" href="tools.html">eyekit.tools</a></code></dt>
<dd>
<div class="desc"><p>Functions for performing common procedures, such as discarding out of
bounds fixations and snapping fixations to the lines of text.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="eyekit Home" href="index.html">
<img src="logo.png" alt="Eyekit logo" width='200'>
</a>
</header>
<br />
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = 'search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<br />
<div class="toc">
<ul>
<li><a href="#is-eyekit-the-right-tool-for-me">Is Eyekit the Right Tool for Me?</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#getting-started">Getting Started</a><ul>
<li><a href="#the-textblock-object">The TextBlock object</a></li>
<li><a href="#the-fixationsequence-object">The FixationSequence object</a></li>
</ul>
</li>
<li><a href="#analysis">Analysis</a></li>
<li><a href="#visualization">Visualization</a></li>
<li><a href="#multiline-passages">Multiline Passages</a></li>
<li><a href="#inputoutput">Inputâ€“Output</a></li>
<li><a href="#getting-your-data-into-eyekit">Getting Your Data into Eyekit</a><ul>
<li><a href="#fixation-data">Fixation data</a></li>
<li><a href="#text-data">Text data</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Documentation</h3>
<ul>
<li><code><a title="eyekit.analysis" href="analysis.html">eyekit.analysis</a></code></li>
<li><code><a title="eyekit.fixation" href="fixation.html">eyekit.fixation</a></code></li>
<li><code><a title="eyekit.image" href="image.html">eyekit.image</a></code></li>
<li><code><a title="eyekit.io" href="io.html">eyekit.io</a></code></li>
<li><code><a title="eyekit.text" href="text.html">eyekit.text</a></code></li>
<li><code><a title="eyekit.tools" href="tools.html">eyekit.tools</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
